<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F03%2F%E5%85%B3%E4%BA%8E%E5%A0%86%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[关于堆栈实现的一点点堆栈是一种逻辑线性结构，具有先入后出，记忆性的特点。 堆栈的实现（存储结构）有两种方式，一种是链表，另一种是数组。 1.链表方式：链表的前插和前摘即为入栈和出栈，栈底在链表末尾，栈顶指针就是指向第一个节点的指针， 而用链表方式的优点是几乎不会出现栈满的情况。 这里说几乎的意思是因为内存毕竟是有限的，但是操作系统提供虚拟存储功能， 虚拟存储意为将内存中暂时不用的空间交换到外存去，所以实际取决于外存的大小， 在有云存储技术之后，基本可以不用考虑栈满， 但是在云存储这种情况下，其速度、效率将受到极大的制约， 因为网络访问肯定比本机存储耗时， 这要考虑带宽问题，此处不做详细说明。 2.数组连续存储结构：对于堆栈的实现我们常用的还是数组方式，它具有以下特点： ①空间利用率比链表高（因为链表还存在链域） ②数组可以通过下标直接访问 ③内存有限，要进行栈满判断 堆栈由控制头和堆栈空间两部分组成 举个栗子： 12345typedef struct KEKSE_STACK&#123; void **stack; int capacity; int top;&#125;KEKSE_STACK； stack成员是堆栈真正的存储空间，它是一个数组，其元素类型是void *， 这个数组是通过malloc ( ) 或 calloc ( ) 函数申请其空间的 代码如下： 1p-&gt;stack = (void **)malloc(sizeof(void *)*capacity); stack数组中的每一个元素都是void *类型，它是要存储的数据的空间的首地址。 ps：关于void *的一点点解释： 我们在堆栈中存放的不是数据，而是这些数据的首地址， 这样可以节省空间，因为指针类型占4B空间， 但是又坚决不能让局部变量的首地址入栈，因为局部变量、形参、实参使用的都是系统堆栈空间， 如果函数运行结束，栈顶、栈底指针就会归回到没被调用前的状态，这个空间就自由了， 而如果中间再有其他函数调用，又会让栈顶指针冒出，这会让里面的值被覆盖。 下列代码主要要实现以下问题： 123456boolean initKekseStack(KEKSE_STACK **head, int capacity); //初始化void destoryKekseStack(KEKSE_STACK **head); //销毁boolean isStackEmpty(const KEKSE_STACK *head); //判空boolean isStackFull(const KEKSE_STACK *head); //判满boolean push(KEKSE_STACK *head, const void *data); //入栈void *pop(KEKSE_STACK *head); //出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define TRUE 1#define FALSE 0#define NOT_FOUND -1void *pop(KEKSE_STACK *head) &#123; if (NULL == head || isStackEmpty(head)) &#123; return NULL; &#125; return head-&gt;stack[--head-&gt;top];&#125;boolean push(KEKSE_STACK *head, const void *data) &#123; if(NULL == head || NULL == data || isStackFull(head)) &#123; return FALSE; &#125; head-&gt;stack[head-&gt;top++] = data; return TRUE;&#125;boolean isStackFull(const KEKSE_STACK *head) &#123; return NULL == head || head-&gt;top &gt; head-&gt;capacity;&#125;boolean isStackEmpty(const KEKSE_STACK *head) &#123; return NULL == head || head-&gt;top &lt;= 0;&#125;void destoryKekseStack(KEKSE_STACK **head) &#123; if (NULL == head || NULL == *head) &#123; return; &#125; free((*head)-&gt;stack); free(*head); *head = NULL;&#125;boolean initKekseStack(KEKSE_STACK **head, int capacity) &#123; KEKSE_STACK *hp; if (NULL == head || NULL != *head || capacity &lt;= 0) &#123; return FALSE; &#125; hp = (KEKSE_STACK *) calloc(sizeof(KEKSE_STACK), 1); if (NULL == hp) &#123; return FALSE; &#125; hp-&gt;stack = (void **) calloc(sizeof(void *), capacity); if (NULL == hp-&gt;stack) &#123; free(hp); return FALSE; &#125; hp-&gt;capacity = capacity; hp-&gt;top = 0; *head = hp; return TRUE;&#125; 以上。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F02%2F1.hexo%E6%90%AD%E5%BB%BAblog%2F</url>
    <content type="text"><![CDATA[hexo 搭建 blog搭建环境准备： 1.下载NodeJs安装文件：https://nodejs.org/en/ 下载完成后检查node是否安装正确，输入下面两条指令： 12node -vnpm -v 如果出现下图就代表安装成功： 2.安装Git：https://gitforwindows.org/ 下载完成后（全部NEXT就好），打开cmd命令行 ，检查Git是否安装正确，输入： 1git --version 出现下图就代表安装成功： 3.在github上注册账号https://github.com/ 第一步：点击右上角Sign up，填写信息 第二步：按右上角New repository 创建成功后如下图： 4.在某盘上创建一个文件夹（建议E盘或F盘）第一步：右键点击Git Bash，进入这个界面： 第二步：全局配置设置到淘宝源： 1npm config set registry https://registry.npm.taobao.org 第三步：设置全局配置user.name和user.email 12git config --global user.name&quot;xxx&quot; //&quot;xxx&quot;中的xxx是刚才Github里面自己注册的账号git config --global user.email&quot;***&quot; //&quot;***&quot;中的***是注册的邮箱 第四步：生成SSH密钥设置到Github 默认生成ssh key在C:\Users\username.ssh文件夹中，用记事本打开id_rsa.pub文件，将内容复制到githu-&gt;settings-&gt;SSH and GPG key -&gt;new ssh key中 第五步：测试ssh设置是否成功 1ssh -T git@github.com 成功如下图： 5.安装hexo插件输入以下代码： 123cd / #进入根目录pwd /npm install hexo-cli -g #安装hexo 安装成功后，输入以下代码： 123456cd /hexo init Hexocd /Hexonpm instalhexo generate(或hexo g)hexo sever（或hexo s） 将最后的网址复制粘贴访问 6.上传hexo博客的静态文档到Github第一步：查看hexo插件的版本 1hexo -v 若hexo版本大于3.0，需要执行该指令： 1npm install -save hexo-deployer-git 第二步：打开电脑中的Hexo文件夹 第三步：右键_config.yml用记事本打开 在最后添加： 1234deploy: type: git repo: git@github.com:heidi233/heidi233.github.io.git branch: master 注意！ ：后要有空格 第四步：部署hexo到github 成功部署如下图： 打开用户名.github.io出现如下界面，搭建成功 ps：对于图片无法显示问题： 第一步：打开_config.yml文件，将第38行post_asset_folder: false 改为 post_asset_folder: true 第二步：安装插件 1npm install https://github.com/CodeFalling/hexo-asset-image --save 第三步：引用图片 在/source/_posts文件夹内再建一个同名文件夹存储图片，然后只需要在xxxx.md中按照markdown的格式引入图片： 1&#123;% asset_img 1.jpg 这是一个新的博客的图片的说明 %&#125; //hexo3用这种格式，而不是以前的![]()方法！ 以上。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
